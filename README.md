# CbmSim -- a Cerebellar Simulation

CbmSim is a biologically-derived, conductance-based, single-compartment spiking model of the cerebellum,
designed by the Mauk Lab at the University of Texas at Austin. CbmSim has two major modes of operation:
synaptogenesis and eyelid conditioning simulation. Further information concerning these two modes can be
found in [Build Mode](#build-mode) and [Run Mode](#run-mode). Most known cerebellar cortex cell populations are included within
the simulation: their types and numbers are as follows:

- Mossy Fibers: 4,096
- Granule Cells: 1,048,576
- Golgi Cells: 4,096
- Basket Cells: 128
- Stellate Cells: 512
- Purkinje Cells: 32
- Deep Cerebellar Nucleus Cells: 8
- Inferior Olive Cells: 4

## Scope
The simulation has been designed in the context of eyelid-conditioning in rabbits and is tuned to this task.
session files are used as eyelid-conditioning training input.

CbmSim can be extended to other tasks, such as different patterns of mossy fiber input and entrainment of multiple
slices or microzones, with the latter currently not being implemented.

## Quickstart

**Prerequisites**

We run our simulations on Ubuntu 22.04 and utilize CUDA to calculate granule cellular activity. The following
table summarizes the general pre-requisites for running simulations with CbmSim:

| Category                  | Prerequisite           |
| ------------------------- | ---------------------- |
| OS                        | Ubuntu 22.04 (x86_64)  |
| GPU Compute Capability    | >= 7.5                 |
| CUDA Version              | >= 12.2                |

A detailed description of the CUDA installation process can be found [here](https://docs.nvidia.com/cuda/archive/12.2.0/cuda-installation-guide-linux/index.html).

**Getting Started**

Once you have fulfilled all of the prerequisites and create a fork of the library so that you can create pull requests in the future.  
After cloning to your account on a simulation computer, you then have to update your .profile located in your home directory.  
Add these two lines to the end of it:

```
export PATH=/usr/local/cuda-12.2/bin${PATH:+:${PATH}}
export LD_LIBRARY_PATH=/usr/local/cuda-12.2/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
```

Now you can compile the source code. Enter the project directory and compile with:

```make```

or if you are interested in development, run:

```make debug```

Running either command will generate the necessary output directories, including the build-outputs as well as
the data output folder.

From there, enter the desired build directory (build or build/debug) and run the binary (./cbm_sim) from there.

## Detailed Usage

For a summary of the various commandline options, run:

```./cbm_sim -h```
or
```./cbm_sim --help```

See [Organization] for a detailed description of the code organization, but generally there are two modes of operation:
build mode and run mode. Build mode creates the connections within/between the cell-layers, and run mode simulates
the dynamics of the network.

#### Build Mode

To build the connectivity arrays, the general command is the following:

```
./cbm_sim -o [OUTPUT_BASE]
```

OUTPUT_BASE specifies the basename that is used to name the output directory and the file basename of the
generated simulation file.  

#### Run Mode

To run a simulation, the general command is the following:

```
./cbm_sim [OPT_ARGS]  -i [INPUT_FILE.sim] -s [SESSION_FILE.json] -o [OUTPUT_BASE] [{OUTPUT_DATA_OPT | OUTPUT_DATA_ARGS}]
```
INPUT_FILE.sim contains the input-state data for the network, which could be generated by running in build mode,
or as the output from a previous run in run mode. See [Session File Specification](#session-file-specification)
for details on the format of the session file. OUTPUT_BASE is the same as build mode, except all outputs from
run mode will be placed there.

The following table summarizes the optional arguments:

| Option           | Argument       | Description                                                                                                     |
| ---------------- | -------------- | ----------------------------------------------------------------------------------------------------------------|
| --visual         | TUI or GUI     | run from the commandline or the GUI                                                                             |
| --pfpc-off       | None           | turn parallel fiber to purkinje cell plasticity off                                                             |
| --binary         | None           | set parallel fiber to purkinje cell plasticity mode to binary (only available in branch seang/shortPlast)        |
| --abbott-cascade | None           | set parallel fiber to purkinje cell plasticity mode to abbott cascade (only available in branch seang/shortPlast)|
| --mauk-cascade   | None           | set parallel fiber to purkinje cell plasticity mode to mauk cascade   (only available in branch seang/shortPlast)|
| --mfnc-off       | None           | turn mossy fiber to deep nucleus plasticity off                                                                 |

The following table summarizes the output data options and arguments:

| Option          | Argument                | Description                                                                      |
| --------------- | ----------------------- | -------------------------------------------------------------------------------- |
| -c or --con-arrs |MFGR,GRGO,MFGO,GOGO,GOGR,BCPC,SCPC,PCBC,PCNC,IOIO,NCIO,MFNC| specify connectivity arrays. saves both pre and post synaptic arrays            |
| -r or --raster  | MF,GR,GO,BC,SC,PC,NC,IO | specify cell-raster data to save. Any subset of the argument is accepted         |
| -p or --psth    | MF,GR,GO,BC,SC,PC,NC,IO | specify cell-psth data to save. Any subset of the argument is accepted           |
| -w or --weights | PFPC,MFNC               | specify plastic synaptic weights to save. Any subset of the argument is accepted |

The argument of all output options must be a comma-separated list of IDs, as given by the Argument column above. Single IDs are
also accepted.

## Organization

The following diagram describes the conceptual organization of CbmSim, where arrows indicate which
module calls functions to either request data or to alter data from another module.

![Screenshot](./organization.svg)

A summary of each module is as follows:

- `main` is the entry point, and interfaces solely with the `control` module.
- `control` module is the arbiter of farming out the main tasks of the simulation, such as constructing connectivity arrays,
  initializing poisson inputs at the mossy fiber layer, and so on.
- `cbm_state` contains the state information of all cellular layers including connectivity relationships and cell-wise activity data. It is polled by `control` when the
  user requests a simulation to be built, and is briefly instantiated from file when the user requests for a simulation
  to be run.
- `cbm_core` is the heart of CbmSim: it sets up memory on the GPUs and is tasked with updating cellular activities
  and then broadcasting these activities as the inputs for downstream neurons. It is also tasked with updating the plasticities
  of the two major sites of plasticity in the cerebellum: the parallel fiber to purkinje cell synapses and the mossy fiber to
  deep cerebellar nucleus synapses.
- `cbm_vis` controls the graphical user interface (GUI) of CbmSim. It polls `control` for simulation-related data, and `control`
  polls it for run-time-related graphical updates while a simulation is running.

Not pictured is `cxx_tools` which includes a myriad of objects and functions that are used throughout the other modules.

## Session File Specification

The basic syntax of a session file is the following:

```
{
   "trials" : {
      "a_trial" : {
         "use_cs": 1,
         "cs_onset": 400,
         "cs_len": 250,
         "cs_percent": 100.0,
         "use_us": 1,
         "us_onset": 650
      },
      "another_trial" : {
         "use_cs": 1,
         "cs_onset": 400,
         "cs_len": 250,
         "cs_percent": 100.0,
         "use_us": 0,
         "us_onset": 650
      },
   },
   "blocks": {
      "a_block" : [
         {"a_trial": 10},
         {"another_trial": 1}
      ],
      "another_block" : [
         {"a_trial": 5},
         {"another_trial": 1}
      ]
   },
   "session": [
      {"a_block": 10},
      {"another_block": 5}
   ]
}

```
Because session files are json files, all rules concerning correct json syntax apply. For our purposes  
though, we require a few specific entries:

- `trials`: this entry defines a trial, and it contains a json object whose entries are the parameter
            name and values for that trial definition
- `blocks`: this entry defines a block, and it contains an array of objects, where each object may
            contain a single entry. That entry must have a key that is a valid trial name, and the value
            must be non-negative. Only disaster awaits those who create negative trials.
- `session`: this entry defines a session, and it contains an array of objects, where each object must
             have a single entry. That entry may have a key that is either a previously-defined trial
             or block. As in the blocks entry, the values must be non-negative. Or else.

Comments are not supported by json files, and for now even the trick of creating a dummy entry containing  
a key saying something like "comment" and a value containing the comment is unsupported. Perhaps this is a  
feature that you can add to the project ;-)

## Contributing

1. Check the open issues or open a new issue to discuss ideas (implementation-wise or scientifically-wise!) or any bugs
   you found (we're still in alpha here folks, so the more bug-fixes now the better!)
2. Fork the repository and play around on your own
3. Open a new pull request

## Contact

If you have any questions beyond that which can be answered via the issues or pull-request page, please contact 
[Sean Gallogly](mailto:sean.gallo@austin.utexas.edu)

## Changelog

See [CHANGELOG](./CHANGELOG.md) for an account of the different releases for this project.

